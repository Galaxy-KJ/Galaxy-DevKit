//! Mock Oracle Contract for Testing
//!
//! This is a simplified price oracle contract that provides:
//! - Price feeds for different asset pairs
//! - Multiple data sources aggregation
//! - Historical price data
//! - Confidence intervals
//!
//! WARNING: This is a MOCK contract for testing only.
//! It does NOT implement real oracle logic.

use soroban_sdk::{contract, contractimpl, symbol_short, Env, Symbol, Bytes, Vec};

#[contract]
pub struct MockOracle;

#[contractimpl]
impl MockOracle {
    /// Get price for a trading pair
    ///
    /// # Arguments
    /// * `env` - Soroban environment
    /// * `base` - Base asset (e.g., "XLM")
    /// * `quote` - Quote asset (e.g., "USD")
    ///
    /// # Returns
    /// * Price data or error
    pub fn get_price(env: Env, base: Bytes, quote: Bytes) -> Result<(Int128, u64, Int128), Symbol> {
        // Validate inputs
        if base.len() == 0 || quote.len() == 0 {
            return Err(symbol_short!("inv_pair")); // Invalid pair
        }

        // In a real oracle, this would:
        // 1. Check price source (Chainlink, Pyth, etc.)
        // 2. Aggregate multiple data sources
        // 3. Calculate median price
        // 4. Return price with confidence interval
        // 5. Check staleness

        // For testing, return mock prices based on pair
        let (price, confidence) = match (base.as_ref(), quote.as_ref()) {
            (b"XLM", b"USD") => (35_000_000, 1_000_000),        // 0.35 USD per XLM
            (b"USDC", b"USD") => (1_000_000_000, 100_000),      // 1.00 USD per USDC
            (b"BTC", b"USD") => (43_000_000_000_000, 100_000_000), // 43,000 USD per BTC
            (b"ETH", b"USD") => (2_300_000_000_000, 50_000_000), // 2,300 USD per ETH
            _ => return Err(symbol_short!("no_pair")),           // Pair not found
        };

        let timestamp = env.ledger().timestamp();

        Ok((price, timestamp, confidence))
    }

    /// Get latest price for a trading pair (convenience method)
    ///
    /// # Arguments
    /// * `env` - Soroban environment
    /// * `base` - Base asset
    /// * `quote` - Quote asset
    ///
    /// # Returns
    /// * Price only (stripped of timestamp/confidence)
    pub fn price(env: Env, base: Bytes, quote: Bytes) -> Result<Int128, Symbol> {
        let (price, _, _) = Self::get_price(env, base, quote)?;
        Ok(price)
    }

    /// Check if price is stale
    ///
    /// # Arguments
    /// * `env` - Soroban environment
    /// * `base` - Base asset
    /// * `quote` - Quote asset
    /// * `max_age` - Maximum age in seconds
    ///
    /// # Returns
    /// * true if price is stale, false otherwise
    pub fn is_stale(
        env: Env,
        base: Bytes,
        quote: Bytes,
        max_age: u64,
    ) -> Result<bool, Symbol> {
        let (_, timestamp, _) = Self::get_price(env.clone(), base, quote)?;
        let current_timestamp = env.ledger().timestamp();

        // Price is stale if older than max_age
        Ok(current_timestamp > timestamp + max_age)
    }

    /// Get price with confidence interval
    ///
    /// # Arguments
    /// * `env` - Soroban environment
    /// * `base` - Base asset
    /// * `quote` - Quote asset
    ///
    /// # Returns
    /// * Tuple of (price, confidence)
    pub fn get_price_with_confidence(
        env: Env,
        base: Bytes,
        quote: Bytes,
    ) -> Result<(Int128, Int128), Symbol> {
        let (price, _, confidence) = Self::get_price(env, base, quote)?;
        Ok((price, confidence))
    }

    /// Update price (for testing/admin)
    ///
    /// WARNING: In a real contract, this would only work with
    /// authenticated oracle signers. This is purely for mocking.
    pub fn update_price(
        env: Env,
        base: Bytes,
        quote: Bytes,
        price: Int128,
    ) -> Result<(), Symbol> {
        // Validate price
        if price <= 0 {
            return Err(symbol_short!("inv_price")); // Invalid price
        }

        // In a real contract, this would:
        // 1. Verify caller is authorized signer
        // 2. Update price in storage
        // 3. Emit event

        // For testing, just return success
        Ok(())
    }

    /// Get supported trading pairs
    ///
    /// # Returns
    /// * Vector of supported base assets
    pub fn supported_bases(env: Env) -> Vec<Bytes> {
        let mut bases = Vec::new(&env);
        bases.push_back(Bytes::from_slice(&env, b"XLM"));
        bases.push_back(Bytes::from_slice(&env, b"USDC"));
        bases.push_back(Bytes::from_slice(&env, b"BTC"));
        bases.push_back(Bytes::from_slice(&env, b"ETH"));
        bases
    }
}

// Import Int128 type
use soroban_sdk::Int128;