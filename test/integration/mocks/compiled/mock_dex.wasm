//! Mock Decentralized Exchange (DEX) Contract for Testing
//!
//! This is a simplified DEX contract that allows:
//! - Swapping tokens (TokenA for TokenB)
//! - Creating liquidity pools
//! - Adding/removing liquidity
//! - Getting exchange rates
//!
//! WARNING: This is a MOCK contract for testing only.
//! It does NOT implement real AMM (Automated Market Maker) logic.

use soroban_sdk::{contract, contractimpl, symbol_short, Env, Symbol, Address, Int128};

#[contract]
pub struct MockDEX;

/// Events for DEX operations
pub mod events {
    use soroban_sdk::{symbol_short, Env, Symbol, Address, Int128};

    pub(crate) fn swap(env: &Env, user: &Address, amount_in: Int128, amount_out: Int128) {
        env.events()
            .publish((symbol_short!("swap"),), (user, amount_in, amount_out));
    }

    pub(crate) fn add_liquidity(env: &Env, provider: &Address, amount_a: Int128, amount_b: Int128) {
        env.events()
            .publish((symbol_short!("addliq"),), (provider, amount_a, amount_b));
    }

    pub(crate) fn remove_liquidity(env: &Env, provider: &Address, amount_a: Int128, amount_b: Int128) {
        env.events()
            .publish((symbol_short!("remliq"),), (provider, amount_a, amount_b));
    }
}

#[contractimpl]
impl MockDEX {
    /// Swap TokenA for TokenB
    ///
    /// # Arguments
    /// * `env` - Soroban environment
    /// * `user` - User initiating swap
    /// * `amount_in` - Amount of TokenA to sell
    /// * `min_amount_out` - Minimum amount of TokenB to receive
    ///
    /// # Returns
    /// * Amount of TokenB received
    pub fn swap(
        env: Env,
        user: Address,
        amount_in: Int128,
        min_amount_out: Int128,
    ) -> Result<Int128, Symbol> {
        // Validate amounts
        if amount_in <= 0 {
            return Err(symbol_short!("inv_in")); // Invalid input amount
        }
        if min_amount_out <= 0 {
            return Err(symbol_short!("inv_out")); // Invalid output amount
        }

        // In a real DEX, this would:
        // 1. Get current exchange rate from pool
        // 2. Calculate output amount (with 0.3% fee)
        // 3. Verify output >= min_amount_out
        // 4. Transfer TokenA from user to contract
        // 5. Transfer TokenB from contract to user
        // 6. Update pool reserves

        // For testing: 1 XLM = 5 USDC (fixed rate)
        let amount_out = (amount_in * 5) / 10;

        if amount_out < min_amount_out {
            return Err(symbol_short!("slip")); // Slippage too high
        }

        events::swap(&env, &user, amount_in, amount_out);
        Ok(amount_out)
    }

    /// Add liquidity to the pool
    ///
    /// # Arguments
    /// * `env` - Soroban environment
    /// * `provider` - Liquidity provider address
    /// * `amount_a` - Amount of TokenA to add
    /// * `amount_b` - Amount of TokenB to add
    ///
    /// # Returns
    /// * Amount of LP tokens minted
    pub fn add_liquidity(
        env: Env,
        provider: Address,
        amount_a: Int128,
        amount_b: Int128,
    ) -> Result<Int128, Symbol> {
        // Validate amounts
        if amount_a <= 0 || amount_b <= 0 {
            return Err(symbol_short!("inv_amt")); // Invalid amount
        }

        // In a real DEX, this would:
        // 1. Check if pool exists
        // 2. Verify amounts match pool ratio
        // 3. Calculate LP tokens to mint
        // 4. Transfer TokenA and TokenB from provider
        // 5. Mint LP tokens to provider

        // For testing: LP tokens = sqrt(amount_a * amount_b)
        let lp_tokens = (((amount_a as u64) * (amount_b as u64)) as f64).sqrt() as i128;

        events::add_liquidity(&env, &provider, amount_a, amount_b);
        Ok(lp_tokens)
    }

    /// Remove liquidity from the pool
    ///
    /// # Arguments
    /// * `env` - Soroban environment
    /// * `provider` - Liquidity provider address
    /// * `lp_tokens` - Amount of LP tokens to burn
    ///
    /// # Returns
    /// * Tuple of (TokenA amount, TokenB amount) received
    pub fn remove_liquidity(
        env: Env,
        provider: Address,
        lp_tokens: Int128,
    ) -> Result<(Int128, Int128), Symbol> {
        // Validate amount
        if lp_tokens <= 0 {
            return Err(symbol_short!("inv_lp")); // Invalid LP tokens
        }

        // In a real DEX, this would:
        // 1. Check provider has enough LP tokens
        // 2. Calculate proportional amounts
        // 3. Burn LP tokens
        // 4. Transfer TokenA and TokenB to provider

        // For testing: proportional amounts (mock)
        let amount_a = lp_tokens * 100;
        let amount_b = lp_tokens * 500;

        events::remove_liquidity(&env, &provider, amount_a, amount_b);
        Ok((amount_a, amount_b))
    }

    /// Get exchange rate (TokenA -> TokenB)
    ///
    /// # Returns
    /// * Rate as integer (1000 = 1.0)
    pub fn exchange_rate(env: Env) -> Int128 {
        // Return 1 XLM = 5 USDC
        5_000
    }

    /// Get pool reserves
    ///
    /// # Returns
    /// * Tuple of (TokenA reserve, TokenB reserve)
    pub fn pool_reserves(env: Env) -> (Int128, Int128) {
        // Return mock pool reserves
        // TokenA: 100,000 XLM
        // TokenB: 500,000 USDC
        (100_000_000_000, 500_000_000_000)
    }

    /// Get liquidity provided
    ///
    /// # Arguments
    /// * `env` - Soroban environment
    /// * `provider` - Liquidity provider address
    ///
    /// # Returns
    /// * Amount of LP tokens held by provider
    pub fn liquidity_of(env: Env, provider: Address) -> Int128 {
        // For testing, return 10,000 LP tokens
        10_000_000_000
    }
}